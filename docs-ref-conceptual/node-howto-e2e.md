---
title: Разработка приложений Node.js с помощью Visual Studio Code и Azure
description: Выполните инструкции из этого руководства, в котором объясняется, как создать приложение Node.js, поместить его в образ Docker и развернуть в Azure
services: multiple
author: tomarcher
manager: douge
ms.service: azure-nodejs
ms.tgt_pltfrm: na
ms.devlang: nodejs
ms.topic: article
ms.date: 06/25/2017
ms.author: joncart
ms.openlocfilehash: 1b43502394b7224c5791ee870999cdb958a0969d
ms.sourcegitcommit: 9974b43899e98df10253738dab5b09b484ac1bf5
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2017
ms.locfileid: "20908144"
---
# <a name="nodejs-development-with-visual-studio-code-and-azure"></a>Разработка приложений Node.js с помощью Visual Studio Code и Azure

В этом руководстве объясняется, как контейнезировать существующее приложение Node.js (с помощью Docker) и развернуть его в Azure с помощью Visual Studio Code.

В руководстве используется простое приложение со списком задач, созданное и опубликованное [Scotch.io](https://scotch.io/tutorials/creating-a-single-page-todo-app-with-node-and-angular). Это одностраничное приложение MEAN, которое использует MongoDB в качестве базы данных, Node/Express для API REST/веб-сервера и Angular.js 1.x для внешнего пользовательского интерфейса. 

## <a name="prerequisites"></a>Предварительные требования

Чтобы продолжить работу с примером, подготовьте следующие компоненты:

- [Visual Studio Code](https://code.visualstudio.com/)
- [Docker](https://www.docker.com/products/docker)
- [Учетная запись DockerHub](https://hub.docker.com/)
- [Azure CLI 2.0](https://docs.microsoft.com/cli/azure/install-az-cli2)
- [Учетная запись Azure](https://azure.microsoft.com/free/)
- [Yarn](https://yarnpkg.com/en/docs/install)
- [Chrome](https://www.google.com/chrome/browser/desktop/) — требуется для отладки интерфейса примера приложения.
- MongoDB — так как пример приложения использует MongoDB, требуется выполняющийся в локальной среде экземпляр MongoDB, который прослушивает стандартный порт `27017`. Чтобы получить этот экземпляр, после установки Docker выполните две команды: сначала `docker pull mongo`, а затем `docker run -it -p 27017:27017 mongo`.

## <a name="project-setup"></a>Настройка проекта

Чтобы приступить к работе, скачайте пример проекта, как описано ниже.

1. Откройте Visual Studio Code.

1. Нажмите клавишу **&lt;F1>**, чтобы отобразить палитру команд.

1. В строке палитры команд введите `gitcl`, выберите команду **Git: Clone** и нажмите клавишу  **&lt;ВВОД>**.

    ![Команда gitcl в строке командной палитры Visual Studio Code](./media/node-howto-e2e/git-clone.png)

1. Если появится запрос ввести **URL-адрес репозитория**, введите `https://github.com/scotch-io/node-todo`, затем нажмите клавишу **&lt;ВВОД>**.

1. Выберите (или создайте) локальный каталог, в который нужно клонировать проект.

    ![Обозреватель Visual Studio Code](./media/node-howto-e2e/explorer.png)

## <a name="integrated-terminal"></a>Встроенный терминал

Так как это проект Node.js, сначала необходимо установить все зависимости проекта из npm.  

1. Нажмите клавишу **&lt;CTRL>**, чтобы отобразить встроенный терминал Visual Studio Code. 

1. Введите `yarn` и нажмите клавишу **&lt;ВВОД>**.  

    ![Выполнение команды yarn в Visual Studio Code](./media/node-howto-e2e/terminal.png)

## <a name="integrated-git-version-control"></a>Встроенная система управления версиями Git

После установки зависимостей приложения с помощью Yarn создается файл `yarn.lock`, который позволяет повторно запрашивать эти же зависимости в будущем без сюрпризов со стороны сборок непрерывной интеграции, рабочих развертываний или компьютеров других разработчиков.

Ниже показано, как добавить файл `yarn.lock` в систему управления версиями:

1. В Visual Studio Code откройте вкладку встроенной системы Git (вкладка с эмблемой Git).

1. В поле **Сообщение** введите сообщение фиксации и нажмите клавиши **&lt;CTRL>&lt;ВВОД>**. 

    ![Добавление файла yarn.lock в Git](./media/node-howto-e2e/git.png)

## <a name="project-and-code-navigation"></a>Навигация по проекту и коду

Чтобы ориентироваться в базе кода, поэкспериментируем с возможностями навигации в среде Visual Studio Code.

1. Нажмите клавиши **&lt;CTRL>P**.

1. Введите `.js`, чтобы отобразить файлы JavaScript/JSON рядом с родительской папкой каждого файла. 

    ![Отображение всех JS-файлов](./media/node-howto-e2e/git-output.png)

1. Выберите файл `server.js`, который является скриптом запуска приложения. 

1. Наведите указатель мыши на переменную **database** (импортирована в строку 6), чтобы просмотреть ее тип. Эта возможность быстро проверять переменные, модули и типы в файле очень удобна при разработке проектов. 

    ![Обнаружение типа](./media/node-howto-e2e/hover-help.png)

1. Нажмите кнопку мыши в пределах диапазона переменной, например **database**, чтобы просмотреть все ссылки на эту переменную в том же файле. Чтобы просмотреть все ссылки на переменную в проекте, щелкните переменную правой кнопкой мыши и в контекстном меню выберите **Найти все ссылки**.

    ![Поиск ссылок на переменную](./media/node-howto-e2e/word-hilight.png)

1. Вы также можете просмотреть определение переменной, даже если оно находится в другом файле. Для этого щелкните правой кнопкой мыши **database.localUrl** (строка 12) и в контекстном меню выберите **Показать определение**. 

    ![Отображение определения переменной](./media/node-howto-e2e/code-peek.png)

## <a name="modifying-the-code-and-using-autocompletion"></a>Изменение кода и использование автозаполнения

Строка подключения MongoDB программно задана в объявлении **database.localUrl**. Выполнив инструкции из этого раздела, вы измените код, чтобы получить строку подключения из переменной среды. Вы также узнаете о функции автозаполнения Visual Studio Code.  

1. Откройте файл `server.js`.

1. Замените код 

    ```javascript
    mongoose.connect(database.localUrl);
    ```

    следующим:

    ```javascript
    mongoose.connect(process.env.MONGODB_URL || database.localUrl);
    ```

Обратите внимание: если при вводе кода вручную (вместо копирования и вставки) поставить точку после `process`, Visual Studio Code отобразит список доступных элементов глобального API **process** Node.js.

![Автозаполнение автоматически отображает элементы API](./media/node-howto-e2e/process-env.png)

Автозаполнение работает, потому что Visual Studio Code использует TypeScript в фоновом режиме (даже для JavaScript), чтобы передавать информацию о вводе, которая может передаваться в список завершения при вводе. Visual Studio Code может определить, что проект является проектом Node.js, и автоматически скачать файл вводимых элементов TypeScript для [Node.js из NPM](https://www.npmjs.com/package/@types/node). Файл вводимых элементов позволяет получить автозаполнение для других глобальных значений Node.js, например **Buffer** и **setTimeout**, а также все встроенные модули, такие как **fs** и **http**.

Кроме встроенных API-интерфейсов Node.js, функция автоматического получения значений также поддерживает более 2000 модулей сторонних производителей, таких как React, Underscore и Express. Например, чтобы не позволить Mongoose аварийно завершать работу приложения, если оно не может подключиться к настроенному экземпляру базы данных MongoDB, вставьте следующую строку кода в строку 13:

```javascript
mongoose.connection.on("error", () => { console.log("DB connection error"); });
```

Как и при использовании предыдущего кода, вы получите автозаполнение автоматически.

![Автозаполнение автоматически отображает элементы API](./media/node-howto-e2e/mongoose.png)

Модули, которые поддерживает эта функция автозаполнения, можно увидеть в созданном сообществом проекте [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped), который является источником для всех определений типов TypeScript.

## <a name="running-the-app"></a>Выполнение приложения

Теперь, когда вы познакомились с кодом, пришло время запустить приложение. Чтобы запустить приложение из Visual Studio Code, нажмите клавишу **&lt;F5>**. При запуске кода с помощью **&lt;F5>** (режим отладки) Visual Studio Code запускает приложение и показывает окно **консоли отладки**, отображающее StdOut для приложения.

![Мониторинг StdOut приложения в консоли отладки](./media/node-howto-e2e/console.png)

Кроме того, **консоль отладки** подключается к только что запущенному приложению, чтобы вы могли вводить выражения JavaScript, которые будут обрабатываться в приложении. В этой консоли также есть функция автоматического заполнения. Чтобы увидеть, как это работает, введите в консоли `process.env`:

![Ввод кода в консоль отладки](./media/node-howto-e2e/console-code.png)

Вы смогли запустить приложение нажатием клавиши **&lt;F5>**, так как открытый сейчас файл является файлом JavaScript (`server.js`). Поэтому Visual Studio Code предполагает, что проект является приложением Node.js. Закройте все файлы JavaScript в Visual Studio Code и нажмите клавишу **&lt;F5>**. В Visual Studio Code появится запрос на выбор среды:

![Выбор среды выполнения](./media/node-howto-e2e/select-env.png)

Откройте браузер и перейдите к `http://localhost:8080`, чтобы просмотреть запущенное приложение. Введите сообщение в текстовое поле и добавьте или удалите несколько задач, чтобы понять, как работает приложение.

![Запуск приложения со списком задач](./media/node-howto-e2e/todo.png)

## <a name="debugging"></a>Отладка

Кроме того что в Visual Studio Code можно запустить приложение и взаимодействовать с ним через консоль, это средство также позволяет задавать точки останова непосредственно в коде. Например, нажмите клавиши **&lt;CTRL>P**, чтобы отобразить средство выбора файлов. Когда откроется средство выбора файлов, введите `route` и выберите файл `route.js`.

Установите точку останова на строке 28, представляющей маршрут Express (вызывается, когда приложение пытается добавить запись из списка задач). Чтобы задать точку останова, щелкните область слева от номера строки в редакторе, как показано на следующем рисунке.

![Настройка точки останова в Visual Studio Code](./media/node-howto-e2e/breakpoint.png)

> [!NOTE]
> Помимо стандартных точек останова, средство Visual Studio Code поддерживает условные точки останова, которые позволяют указать время остановки приложения. Чтобы задать условную точку останова, щелкните правой кнопкой мыши область слева от строки, в которой нужно приостановить выполнение, выберите **Добавить условную точку останова...** и укажите выражение JavaScript (например, `foo = "bar"`) или число операций выполнения, определяющих условие, при котором приложение должно быть остановлено.
> 
> 

Установив точку останова, вернитесь к выполняемому приложению и добавьте запись из списка задач. Добавление такой записи немедленно останавливает выполнение приложения на строке 28, где вы задали точку останова:

![Visual Studio Code приостанавливает выполнение на точке останова](./media/node-howto-e2e/debugger.png)

Когда приложение будет приостановлено, можно навести указатель мыши на выражения кода, чтобы просмотреть их текущие значения, проверить локальные переменные или контрольные значения и стек вызовов, а также использовать панель инструментов отладки для пошагового выполнения кода. Нажмите клавишу **&lt;F5>**, чтобы возобновить выполнение приложения.

## <a name="full-stack-debugging"></a>Отладка полного стека

Как упоминалось выше, приложение со списком задач — это приложение MEAN, то есть приложение, интерфейс и серверная часть которого написаны с помощью JavaScript. То есть, если вы выполняете отладку серверного кода (Node/Express), в определенный момент может потребоваться отладить код интерфейса (Angular). Для этого в Visual Studio Code есть множество расширений, в том числе встроенная отладка Chrome.

Откройте вкладку **Расширения** и введите `chrome` в поле поиска:

![Расширение отладки Chrome для Visual Studio Code](./media/node-howto-e2e/chrome.png)

Выберите расширение с именем **Отладчик для Chrome** и выберите **Установить**. Установив расширение отладки Chrome, щелкните **Перезагрузить**, чтобы закрыть и снова открыть Visual Studio Code для активации расширения. 

![Перезагрузка Visual Studio Code после установки расширения отладки Chrome](./media/node-howto-e2e/chrome-extension-reload-vscode.png)

Хотя вы смогли выполнить и отладить код Node.js без специальной настройки Visual Studio Code, чтобы отладить внешнее веб-приложение, необходимо создать файл `launch.json`, который сообщает Visual Studio Code, как запускать приложение. 

Чтобы создать файл `launch.json`, откройте вкладку **Отладка**, щелкните значок шестеренки (на нем должна быть небольшая красная точка вверху) и выберите среду **node.js**.

![Настройка файла launch.json в Visual Studio Code](./media/node-howto-e2e/debug-gear.png)

Созданный файл `launch.json` выглядит, как на снимке экрана ниже. Этот файл сообщает Visual Studio Code, как запустить приложение или как подключиться к нему, чтобы выполнить его отладку. 

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "Launch Program",
            "program": "${workspaceRoot}/server.js"
        },
        {
            "type": "node",
            "request": "attach",
            "name": "Attach to Port",
            "address": "localhost",
            "port": 5858
        }
    ]
}
```

Обратите внимание: средство Visual Studio Code определило, что скриптом запуска приложения является `server.js`. 

Откройте файл `launch.json`, нажмите кнопку **Добавить конфигурацию** (внизу справа) и выберите **Chrome: Launch with userDataDir** (Chrome: запустить с использованием userDataDir).

![Добавление конфигурации Chrome в Visual Studio Code](./media/node-howto-e2e/add-chrome-config.png)

Добавление новой конфигурации запуска для Chrome позволяет отладить внешний код JavaScript. 

Наведите указатель мыши на любой заданный параметр, чтобы увидеть его функцию. Кроме того, обратите внимание, что Visual Studio Code автоматически определяет URL-адрес приложения. Задайте для свойства **webRoot** значение `${workspaceRoot}/public`, чтобы отладчик Chrome знал, где найти внешние ресурсы приложения:

```json
{
   "type": "chrome",
   "request": "launch",
   "name": "Launch Chrome",
   "url": "http://localhost:8080",
   "webRoot": "${workspaceRoot}/public",
   "userDataDir": "${workspaceRoot}/.vscode/chrome"
}
```

Чтобы запустить или выполнить отладку внешнего и внутреннего кода одновременно, необходимо создать *комплексную* конфигурацию запуска, которая сообщает средству Visual Studio Code, какой набор конфигураций нужно выполнять параллельно. 

Добавьте следующий фрагмент кода в качестве свойства верхнего уровня в файл `launch.json` (как одноуровневое свойство существующего свойства **configurations**).

```json
"compounds": [
   {
      "name": "Full-Stack",
      "configurations": ["Launch Program", "Launch Chrome"]
   }
]
```

Строковые значения, указанные в массиве **compounds.configurations**, ссылаются на **имя** отдельных записей в списке **конфигураций**. Если вы уже изменили эти имена, внесите соответствующие изменения в массив. Чтобы увидеть, как это работает, перейдите на вкладку "Отладка" и выберите для выбранной конфигурации значение **Полный стек** (имя составного конфигурации) и нажмите клавишу **&lt;F5>** для запуска.

![Выполнение конфигурации в Visual Studio Code](./media/node-howto-e2e/full-stack-profile.png)

Выполнение конфигурации запускает приложение Node.js (это можно увидеть в выходных данных консоли отладки) и Chrome (который настроен для перехода к приложению Node.js по адресу `http://localhost:8080`).

Нажмите клавиши **&lt;Ctrl>P** и введите (или выберите) значение `todos.js`, которое является основным контроллером Angular внешней части приложения. 

Установите точку останова на строке 11, которая является точкой входа для создаваемой записи из списка задач.

Вернитесь к выполняемому приложению и добавьте новую запись. Вы увидите, что средство Visual Studio Code приостановило выполнение кода Angular.

![Отладка внешнего кода в Visual Studio Code](./media/node-howto-e2e/chrome-pause.png)

Как и во время отладки Node.js, можно навести указатель мыши на выражения, просмотреть локальные переменные и контрольные значения, обработать выражения в консоли и т. д. 

Необходимо обратить внимание на два важных момента.

1. В области **Стек вызовов** отображаются два разных стека: **Node** и **Chrome**. При этом указано, какой из стеков приостановлен.

1. Можно переходить между внутренним и внешним кодом. Нажмите клавишу **&lt;F5>**, чтобы запустить и активировать точку останова, заданную ранее в маршруте Express.

После этого вы можете эффективно отладить внешний и внутренний код JavaScript или код полного стека JavaScript непосредственно в Visual Studio Code. 

Концепция комплексного отладчика не ограничивается только двумя целевыми процессами и кодом JavaScript. Поэтому, если вы работаете с приложением-микрослужбой (это может быть polyglot), можно использовать тот же рабочий процесс (после установки соответствующих расширений для языка или платформы).

## <a name="dockerizing-the-app"></a>Включение приложения в образ Docker

В этом разделе рассказывается о возможностях Visual Studio Code для разработки с помощью [Docker](https://www.docker.com/). Разработчики Node.js используют Docker, чтобы предоставлять развертывания переносимых приложений для сред разработки, непрерывной интеграции и рабочих сред. Так как Docker является довольно сложным инструментом, Visual Studio Code предоставляет расширение, которое помогает использовать Docker в приложениях.

Вернитесь на вкладку **Расширения**, выполните поиск по запросу `docker` и выберите расширение **Docker**. 

Установите расширение Docker, а затем перезагрузите Visual Studio Code.

![Установка расширения Docker для Visual Studio Code](./media/node-howto-e2e/docker-search.png)

Расширение Docker для Visual Studio Code включает команду для создания *Dockerfile* и файла `docker-compose.yml` для существующего проекта. 

Чтобы просмотреть доступные команды Docker, откройте палитру команд. Для этого нажмите клавишу **&lt;F1>** и введите `docker`.

![Команды для Visual Studio, которые поддерживает расширение Docker ](./media/node-howto-e2e/docker-commands.png)

Выберите **Docker: Add docker files to workspace** (Docker: добавление файлов docker в рабочую область), выберите **Node.js** в качестве платформы приложения и укажите, что приложение предоставляет порт `8080`. 

Команда Docker создает полный файл `Dockerfile` и файлы docker-compose, которые вы можете сразу использовать.

![Созданный файл Dockerfile](./media/node-howto-e2e/docker-file.png)

Расширение Docker также обеспечивает автоматическое заполнение для файлов `Dockerfiles` и `docker-compose.yml`. 

Чтобы увидеть, как это работает, откройте `Dockerfile` и измените строку 2:

```docker
FROM node:latest
```

на:

```docker
FROM mhart
```

Установите курсор после `t` в `mhart`, нажмите клавиши **&lt;CTRL>&lt;Пробел>**, чтобы просмотреть все репозитории образов, которые команда `mhart` опубликовала в DockerHub.

![Автоматическое заполнение расширения Docker](./media/node-howto-e2e/docker-completion.png)

Выберите команду `mhart/alpine-node`, которая предоставляет все необходимое для приложения. 

Лучше создавать небольшие образы, так как с их помощью приложения можно быстрее построить и развернуть. Это позволяет быстрее распространять их и масштабировать.

Теперь, когда вы создали файл `Dockerfile`, нужно собрать фактический образ Docker. Не забывайте, что можно использовать команду, которую установило расширение Docker в Visual Studio Code. Нажмите клавишу **&lt;F1>**, введите `dockerb` на палитре команд, а затем выберите команду **Docker: Build Image** (Docker: сборка образа). Выберите файл `/Dockerfile`, который вы только что создали и изменили. Укажите тег, который включает в себя имя пользователя DockerHub (например, `lostintangent/node`). Нажмите клавишу **&lt;ВВОД>**, чтобы запустить встроенное окно терминала, в котором отображаются выходные данные создаваемого образа Docker.

![Состояние сборки образа Docker](./media/node-howto-e2e/docker-build.png)

Обратите внимание, что команда автоматизировала процесс выполнения `docker build`. Это еще одна возможность повысить производительность. Либо можно использовать интерфейс командной строки Docker CLI напрямую. 

На этом этапе развернутые приложения могут легко получить этот образ. Достаточно просто передать образ в DockerHub. Чтобы сделать это, войдите в DockerHub, запустив `docker login` из интерфейса командной строки и введя учетные данные своей учетной записи. Затем можно открыть палитру команд в Visual Studio Code. Для этого введите `dockerpush` и выберите команду `Docker: Push`. Выберите только что созданный тег изображения (например, `lostintangent/node`) и нажмите клавишу **&lt;ВВОД>**. Команда автоматизирует вызов `docker push` и отображает выходные данные в окне встроенного терминала.

## <a name="deploying-the-app"></a>Развертывание приложения

Теперь, когда вы поместили приложение в образ Docker и передали его в DockerHub, необходимо развернуть приложение в облаке, чтобы оно стало доступным для пользователей. Для этого используйте службу приложений Azure, которая является предложением Azure PaaS. В службе приложений есть две возможности для разработчиков Node.js:

- Поддержка виртуальных машин Linux, минимизирующая несовместимость для приложений, которые созданы с помощью собственных модулей Node, или другие средства, которые могут не поддерживать Windows и (или) вести себя иначе.
- Поддержка развертываний Docker, которая позволяет указать имя образа Docker и дает возможность службе приложений извлекать, развертывать и масштабировать образ автоматически.

Чтобы приступить к работе, откройте терминал Visual Studio. Для управления учетной записью Azure и подготовки инфраструктуры, необходимой для запуска приложения со списком задач, используйте версию Azure CLI 2.0. Войдите в учетную запись из интерфейса командной строки с помощью команды `az login` (как указано в предварительных условиях). Выполните следующие действия, чтобы подготовить экземпляр службы приложений и развернуть контейнер приложения со списком задач:

1. Создайте группу ресурсов, которую можно будет использовать как *пространство имен* или *каталог* для организации ресурсов Azure. С помощью параметра `-n` укажите имя группы.

    ```shell
    az group create -n nina-demo -l westus
    ```

    > [!NOTE]
    > Параметр `-l` указывает расположение группы ресурсов. В предварительной версии службы приложений для Linux можно было только выбирать регионы. Поэтому, если вы не находитесь в западной части США и хотите узнать, какие регионы доступны, выполните в CLI команду `az appservice list-locations --linux-workers-enabled`, чтобы просмотреть варианты выбора центра обработки данных.

2. Назначьте созданную группу ресурсов группой ресурсов по умолчанию, чтобы продолжить использовать CLI и не указывать группу ресурсов при каждом вызове CLI:

   ```shell
   az configure -d group=nina-demo
   ```
   
3. Создайте *план* службы приложений, управляющий созданием и масштабированием базовой виртуальной машины, на которой развертывается приложение. Еще раз укажите любое значение для параметра `n`.

    ```shell
    az appservice plan create -n nina-demo-plan --is-linux
    ```

    > [!NOTE]
    > Параметр --is-linux указывает, что вы создаете виртуальные машины под управлением Linux. Без этого параметра CLI по умолчанию подготавливает виртуальные машины под управлением Windows.

4. Создайте веб-приложение, представляющее фактическое приложение со списком задач, которое будет выполняться в плане и группе ресурсов, которые вы только что создали. Веб-приложение можно считать процессом или контейнером, а план — виртуальной машиной или узлом контейнера, где выполняется веб-приложение. При создании веб-приложения необходимо также настроить его для использования образа Docker, опубликованного в DockerHub:

    ```shell
    az webapp create -n nina-demo-app -p nina-demo-plan -i lostintangent/node
    ``` 

    > [!NOTE]
    > Если вместо пользовательского контейнера вы предпочитаете развертывание Git, см. статью о [создании веб-приложения Node.js в Azure](https://docs.microsoft.com/azure/app-service-web/app-service-web-get-started-nodejs#configure-to-use-nodejs).

5. Назначьте веб-приложение веб-экземпляром по умолчанию:

    ```shell
    az configure -d web=nina-demo-app
    ```

6. Запустите приложение для просмотра развернутого контейнера, который можно найти по URL-адресу `*.azurewebsites.net`:

    ```shell
    az webapp browse
    ```

    ![Приложение со списком задач, выполняющееся в браузере](./media/node-howto-e2e/browse-app.png)

    > [!NOTE]
    > Первый запуск приложения может длиться несколько минут, так как служба приложений должна извлечь образ Docker из DockerHub и запустить его.

На этом этапе вы развернули и запустили приложение со списком задач. 

Теперь у вас есть приложение со списком задач. Но вращающийся значок означает, что приложение не может подключиться к базе данных. Это связано с тем, что во время разработки вы использовали локальный экземпляр MongoDB, который не доступен из центров обработки данных Azure. Так как вы изменили приложение, чтобы принимать строку подключения с помощью переменной среды, достаточно запустить сервер MongoDB и повторно настроить экземпляр службы приложений, чтобы она ссылалась на переменную среды. В следующем разделе объясняется, как это сделать.

## <a name="provisioning-a-mongodb-server"></a>Подготовка сервера MongoDB

Вы можете настроить сервер MongoDB или набор реплик и самостоятельно управлять ИТ-инфраструктурой, но вы также можете использовать решение Azure, которое называется [Cosmos DB](https://azure.microsoft.com/services/documentdb/). Cosmos DB — это полностью управляемая высокопроизводительная база данных NoSQL с функцией георепликации, которая обеспечивает уровень совместимости MongoDB. Это означает, что вы можете указать в ней приложение MEAN (или любой клиент либо средство MongoDB, например [Studio 3T](https://studio3t.com/)) и вам не нужно будет ничего изменять, кроме строки подключения. Далее объясняется, как это сделать.

1. В терминале Visual Studio Code выполните следующую команду, чтобы создать экземпляр службы Cosmos DB, совместимый с MongoDB. Замените заполнитель **<NAME>** глобально уникальным значением (Cosmos DB использует это имя для создания URL-адреса сервера базы данных):

   ```shell
   COSMOSDB_NAME=<NAME>
   az cosmosdb create -n $COSMOSDB_NAME --kind MongoDB
   ```

2. Получите строку подключения MongoDB для этого экземпляра:

   ```shell
   MONGODB_URL=$(az cosmosdb list-connection-strings -n $COSMOSDB_NAME -otsv --query "connectionStrings[0].connectionString")
   ```

3. Обновите переменную среды веб-приложения **MONGODB_URL**, чтобы она подключилась к новому экземпляру Cosmos DB и не пыталась подключиться к локальному серверу MongoDB (которого не существует):

    ```shell
    az webapp config appsettings set --settings MONGODB_URL=$MONGODB_URL
    ```

4. Вернитесь в браузер и обновите его. Попробуйте добавить и удалить элемент списка задач, чтобы убедиться, что приложение работает и в нем не нужно ничего менять. Задайте для переменной среды созданный экземпляр Cosmos DB, который является полной эмуляцией базы данных MongoDB.

    ![Демонстрация приложения после подключения к базе данных](./media/node-howto-e2e/finished-demo.png)

При необходимости можно переключиться обратно на экземпляр базы данных Cosmos DB и увеличить или уменьшить масштаб зарезервированной пропускной способности, необходимой экземпляру MongoDB. Тогда вы получите дополнительный трафик, изменяя инфраструктуру вручную.

Cosmos DB автоматически индексирует каждый документ и его свойства. Поэтому вам не нужно профилировать медленные запросы или вручную регулировать индексы. Просто выполните подготовку и масштабирование, а все остальное сделает Cosmos DB.

## <a name="hosting-a-private-docker-registry"></a>Размещение частного реестра Docker

DockerHub позволяет распространять образы контейнера. Но иногда вам может понадобиться разместить собственный частный реестр Docker, например, чтобы повысить безопасность или производительность либо для более удобного управления. Для этого Azure предоставляет [реестр контейнеров Azure](https://azure.microsoft.com/services/container-registry/) (ACR), который позволяет вам создать собственный реестр Docker, резервное хранилище которого находится в том же центре обработки данных, что и ваше веб-приложение (благодаря этому извлечение происходит быстрее). ACR также предоставляет полный контроль над содержимым и элементами управления доступом. То есть вы решаете, кто может отправлять и извлекать образы. 

Чтобы подготовить пользовательский реестр, выполните следующую команду. Замените заполнитель **<NAME>** глобальным уникальным значением, которое ACR использует для создания URL-адреса сервера входа в реестр.

```shell
ACR_NAME=<NAME>
az acr create -n $ACR_NAME -l westus --admin-enabled
```

> [!NOTE]
> Хотя в этих инструкциях для примера используется **учетная запись администратора**, не рекомендуется использовать ее в рабочих реестрах. 

Команды `az acr create` отображают URL-адрес сервера входа (в столбце `LOGIN SERVER`), используемого для входа с помощью Docker CLI (например, `ninademo.azurecr.io`). Кроме того, команда создает учетные данные администратора, которые можно использовать для проверки подлинности. Чтобы получить такие учетные данные, выполните следующую команду и запишите отображаемое имя пользователя и пароль:

```shell
az acr credential show -n $ACR_NAME
```

С помощью учетных данных, созданных на предыдущем шаге, и отдельного имени входа сервера вы можете войти в реестр, используя стандартный рабочий процесс Docker CLI.

```shell
docker login <LOGIN_SERVER> -u <USERNAME> -p <PASSWORD>
```

Теперь вы можете отметить тегами свой контейнер Docker, чтобы определить связь с частным реестром. Для этого выполните следующую команду (замените `lostintangent/node` именем образа контейнера):

```shell
docker tag lostintangent/node <LOGIN_SERVER>/lostintangent/node
```

Отправьте отмеченный тегами образ в свой частный реестр Docker.

```shell
docker push <LOGIN_SERVER>/lostintangent/node
```

Контейнер теперь хранится в частном реестре. С помощью Docker CLI вы можете продолжать работать с ним, как и при использовании DockerHub. Чтобы настроить веб-приложение службы приложений извлекать образ из частного реестра, выполните следующую команду:

```shell
az appservice web config container set \
    -r <LOGIN_SERVER> \
    -c <LOGIN_SERVER>/lostintangent/node \
    -u <USERNAME> \
    -p <PASSWORD> 
```

> [!NOTE]
> Обязательно добавьте префикс `https://` в начало параметра `-r`. Не добавляйте префикс к имени образа контейнера.

Если обновить приложение в браузере, оно будет выглядеть и работать, как раньше. Но теперь приложение работает с использованием вашего частного реестра Docker. Обновив приложение, отметьте тегами и отправьте изменения, как показано выше, а также обновите тег в конфигурации контейнера службы приложений.

## <a name="configuring-a-custom-domain-name"></a>Настройка пользовательского доменного имени

Хотя URL-адрес `*.azurewebsites.net` отлично подходит для тестирования, в определенный момент может потребоваться добавить собственное доменное имя для веб-приложения. Получив доменное имя у регистратора, вам нужно только добавить запись `A`, которая указывает на внешний IP-адрес веб-приложения (который фактически является подсистемой балансировки нагрузки). Чтобы получить этот IP-адрес, выполните следующую команду:

```shell
az webapp config hostname get-external-ip
```

Кроме добавления записи `A`, добавьте запись `TXT` к своему домену, которая указывает на домен `*.azurewebsites.net`, используемый вами до сих пор. Сочетание записей `A` и `TXT` позволяет Azure убедиться в том, что вы являетесь владельцем домена.

Создав эти записи и распространив изменения DNS, зарегистрируйте пользовательский домен в Azure, чтобы входящий трафик обрабатывался правильно. 

```shell
az webapp config hostname add --hostname <DOMAIN>
```

> [!NOTE]
> Команда не будет работать, пока не будут распространены изменения в DNS.

Откройте браузер и перейдите к пользовательскому домену, чтобы увидеть, что он разрешается в развернутое приложение в Azure.

## <a name="scaling-up-and-out"></a>Увеличение и уменьшение масштаба

Ваше веб-приложение может стать настолько популярным, что его выделенных ресурсов (ЦП и ОЗУ) может не хватать для обработки увеличенного трафика и выполнения операций. План службы приложений, который вы создали ранее (**B1**), предоставляет 1 ядро ЦП и 1,75 ГБ ОЗУ. Эти ресурсы можно израсходовать достаточно быстро. В плане **В2** можно увеличить объем ЦП и ОЗУ в два раза. Поэтому, если вы заметили, что приложению не хватает одного из ресурсов, можно увеличить масштаб базовой виртуальной машины. Для этого выполните следующую команду:

```shell
az appservice plan update -n nina-demo-plan --sku B2
```

> [!NOTE]
> Сведения о ценах и спецификации планов службы приложений Azure см. на странице с [ценами службы приложений](https://azure.microsoft.com/pricing/details/app-service/).

Через несколько секунд веб-приложение будет перенесено на запрошенное оборудование и начнет использовать соответствующие ресурсы. Вы также можете уменьшить масштаб ресурсов. Это можно сделать с помощью той же команды. Только нужно выбрать параметр `--sku`, который предоставляет меньше ресурсов по более низкой цене. 

Если ваше веб-приложение работает без отслеживания состояния, кроме увеличения масштаба спецификаций виртуальной машины, вы также можете *развернуть* рабочую нагрузку, добавив дополнительные экземпляры базовой виртуальной машины. План службы приложений, созданный ранее, включал только одну виртуальную машину (*рабочая роль*). Поэтому весь входящий трафик ограничивался доступными ресурсами этого экземпляра. Если вы хотите добавить второй экземпляр виртуальной машины, выполните ту же команду, которую вы выполняли раньше, но вместо увеличения масштаба SKU увеличьте число рабочих виртуальных машин.

```shell
az appservice plan update -n nina-demo-plan --number-of-workers 2
```

При развертывании рабочей нагрузки такого веб-приложения входящий трафик будет прозрачно сбалансирован между всеми экземплярами. Это позволит сразу увеличивать производительность, не меняя код или инфраструктуру. 

Веб-приложения без отслеживания состояния рекомендуются для использования, так как они позволяют детерминированно увеличивать и уменьшать масштаб, а также развертывать рабочие нагрузки. Это возможно, так как в такой конфигурации ни виртуальные машины, ни экземпляры приложения не содержат состояние, необходимое для работы. 

> [!NOTE]
> Хотя в этой статье приводится пример одного веб-приложения, вы можете создать и развернуть несколько веб-приложений в рамках одного плана службы приложений, чтобы не подготавливать другие планы и не платить за них. 

## <a name="clean-up"></a>Очистка

Чтобы не оплачивать неиспользуемые ресурсы Azure, выполните следующую команду в терминале Visual Studio Code. Так вы удалите все ресурсы, которые были подготовлены при выполнении инструкций из этого руководства.

```shell
az group delete
```

> [!NOTE]
> Процесс очистки может длиться несколько минут. 

После завершения очистки команда `az group delete` оставит вашу учетную запись Azure в том же состоянии, в котором она была до начала работы с руководством. Возможность организовывать, развертывать и удалять ресурсы Azure как единый объект является одним из основных преимуществ групп ресурсов. Поэтому рекомендуется группировать ресурсы, для которых вы планируете одинаковое время существования.